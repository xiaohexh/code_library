// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <getopt.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>

#include <iostream>
#include <deque>

#include "VOSServer.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include "vos_log.h"
#include "vos_conf.h"

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using boost::shared_ptr;

std::deque<const OrderInfo> orderinfoq;

#define VOS_OK	0
#define VOS_ERR	-1

#define CRLF        "\x0d\x0a"

#define LOG_FILE	"./vos.log"
#define CFG_FILE	"./vos.ini"
#define PID_FILE    "./vos.pid"

static int show_help;
static int show_version;
static int daemonize;
char *log_file;
char *cfg_file;
char *pid_file;

static struct option long_options[] = { 
    { "help",       no_argument,    NULL,   'h' },
    { "version",    no_argument,    NULL,   'v' },
    { "daemonize",  no_argument,    NULL,   'd' },
    { "cfg-file",  	no_argument,    NULL,   'c' },
    { "log-file",  	no_argument,    NULL,   'l' },
    { "pid-file",   no_argument,    NULL,   'p' },
    { NULL,         0,              NULL,   0   }   
};

static const char *short_options = "hvdc:l:p:";


int get_options(int argc, char **argv)
{
    int c;

    for (;;) {
        c = getopt_long(argc, argv, short_options, long_options, NULL);
        if (c == -1) {
            break;
        }   

        switch (c) {
        case 'h':
            show_version = 1;
            show_help = 1;
            break;

        case 'v':
            show_version = 1;
            break;

        case 'd':
            daemonize = 1;
            break;

        case 'c':
            cfg_file = optarg;
            break;

        case 'l':
            log_file = optarg;
            break;

        case 'p':
            pid_file = optarg;
            break;

        default:
            // errlog
            printf("invalid option '%c'\n", c);
            return -1;
        }
    }

    return 0;
}

void vos_daemonize(void)
{
    int fd; 

    if (fork() != 0) exit(0); /* parent exits */
    setsid();   /* create a new session */

    if ((fd = open("/dev/null", O_RDWR, 0)) != -1) {
        dup2(fd, STDIN_FILENO);
        dup2(fd, STDOUT_FILENO);
        dup2(fd, STDERR_FILENO);
        if (fd > STDERR_FILENO)
            close(fd);
    }
}

void create_pid_file(void) {
  FILE *fp = fopen(pid_file,"w");
  if (fp) {
    fprintf(fp,"%d\n",(int)getpid());
    fclose(fp);
  }
}

static void show_usage(void)
{
    printf(
        "Usage: VOSServer [-hvd] [-c conf file] [-o output file]" CRLF
        "                 [-p pid file] [-m mbuf size]" CRLF
        "");
    printf(
        "Options:" CRLF
        "  -h, --help             : this help" CRLF
        "  -V, --version          : show version and exit" CRLF
        "  -d, --daemonize        : run as a daemon" CRLF);
    printf(
        "  -c, --cfg-file=S      : set configuration file (default: %s)" CRLF
        "  -l, --log-file=S      : set log file (default: %s)" CRLF
        "  -p, --pid-file=S       : set pid file (default: %s)" CRLF
        "",
        CFG_FILE,
		LOG_FILE,
        PID_FILE != NULL ? PID_FILE : "off"
        );
}

void set_default_options()
{
    cfg_file = CFG_FILE;
    log_file = LOG_FILE;
    pid_file = PID_FILE;
}

int handle_market_end_req(const OrderInfo& oi)
{
	if (oi.flag == 0) {
	} else {
	}
	return VOS_OK;
}

int handle_business_end_req(const OrderInfo& oi)
{
	return VOS_OK;
}

void handle_request()
{
	while (!orderinfoq.empty()) {
		switch (orderinfoq.front().type) {
		case RequestType::BIZ_END:
			handle_business_end_req(orderinfoq.front());
			break;
		case RequestType::MARKET_END:
			handle_market_end_req(orderinfoq.front());
			break;
		default:
			log_warn("invalid request type: %d", orderinfoq.front().type);
			continue;
		}
		orderinfoq.pop_front();
	}
}

class VOSServerHandler : virtual public VOSServerIf {
 public:
  VOSServerHandler() {
    // Your initialization goes here
  }

  void SendOrderInfo(const OrderInfo& oi) {
    // Your implementation goes here
	log_debug(LOG_DEBUG, "recv order info from client");
	orderinfoq.push_back(oi);
  }
};

int init_server()
{
  int status;

  status = log_init(LOG_DEBUG, log_file);
  if (status < 0) {
	  log_stderr("log_init failed");
	  return VOS_ERR;
  }

  VOSConfig *my_config = VOSConfig::instance();
  status = my_config->loadConfigFile(cfg_file);
  if (status < 0) {
      log_error("load config file '%s' failed\n", cfg_file);
	  return VOS_ERR;
  }

  string name = my_config->getConfigStr("Person", "Name");
  int age = my_config->getConfigInt("Person", "Age");

  printf("name:%s age:%d\n", name.c_str(), age);

  return VOS_OK;
}

int main(int argc, char **argv) {

  int port = 9090;
  int status;

  set_default_options();

  status = get_options(argc, argv);
  if (status < 0) {
      fprintf(stderr, "parse common line params failed!\n");
	  exit(0);
  }

  if (show_version) {
      printf("This is Version 1.0.0\n");
      if (show_help) {
          show_usage();
      }
	  exit(0);
  }

  if (daemonize) vos_daemonize();

  status = init_server();
  if (status != VOS_OK) {
	  return 1;
  }

  if (daemonize) create_pid_file();

  shared_ptr<VOSServerHandler> handler(new VOSServerHandler());
  shared_ptr<TProcessor> processor(new VOSServerProcessor(handler));
  shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  shared_ptr<TTransportFactory> transportFactory(new TBufferedTransportFactory());
  shared_ptr<TProtocolFactory> protocolFactory(new TBinaryProtocolFactory());

  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);
  server.serve();
  return 0;
}
